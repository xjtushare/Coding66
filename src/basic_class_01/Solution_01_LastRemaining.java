package basic_class_01;

/*
圆圈中最后剩下的数字

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2

方法一：模拟过程总结：
	int sum = 0;//用来记录当前已经离开圆桌的人数总和
	while(sun<n-1){//说明当前圆桌上剩余的人数大于1的，就继续移除， 
		每次循环进行移除操作的时候，我就将res初始化为0，意思就是说我当前一个人都还没有遍历到。
		while(res<m){
		说明我当前统计的人数还没有到达m个，所以我还不能进行移除学生的操作， 
		不能移除的话，我就继续往下一个位置找，如果当前位置的学生还在(就是没有被移除的话)，
		那么我就res++；就是把当前遍历的人数res变量进行加1操作；直到res==m的话，就说明
		我当前的index-1的位置，那个学生已经被移除了，移除之后，这个地方是需要记录的，即
		vis[(index+n-1)%n] = true;//刚才被移除的元素
		置为true之后，再进行sum++；

		这里有个问题，就是
		应该加入
		while(vis[index]){
				index =(index+1)%n;	
			}

		例如：
		 			0

			4				1


				3		2
		我当前4的位置已经移除了，index现在等于0的位置，但是0这个位置在之前的某一次遍历过程中
		已经被移除了，那么我在本次循环从0开始其实是已经不对了，因为0位置其实已经是移除过了。
		所以：
		while(vis[index]){
				index =(index+1)%n;	
			}
		这个while循环，功能是在某次循环的时候，把这个index去移到没有被移除过的学生的下标位置。

*/
public class Solution_01_LastRemaining {
    public static int LastRemaining_Solution(int n, int m) {
        if (n == 0 || m == 0) {
            return -1;
        }
        boolean[] vis = new boolean[n];// vis[i]=true 代表第i个小朋友离开圆桌
        int sum = 0;//用来记录当前已经离开圆桌的人数总和
        int res = 0;//用来记录某一次循环的过程中，已经计数人数的个数。
        int index = 0;//不断的去遍历圆桌上的每个小朋友，index来保存下标
        while (sum < n - 1) {//说明当前圆桌上剩余的人数大于1的，就不断的去遍历
            //比如从0往1找的时候，0已经被计数过了，res就++;
            res = 0;//res相当于我去遍历第m个位置的时候，我已经找到了res个学生
			/*
				意思就是我还没有统计完m个学生的时候，那么我就去遍历当前index位置的那个学生，
				当前index位置的学生如果还没有被移除的话，那么他对应的vis[index]应该是false
				所以res++；
			*/
            //在某一次循环中，让index处于没有被移除的学生位置
            while (vis[index]) {
                index = (index + 1) % n;
            }
            //模拟找第m个位置的学生
            while (res < m) {
                if (!vis[index]) {
                    res++;
                }
                //右移:相当于我第一个位置找完，现在去找第二个位置
                index = (index + 1) % n;
            }
			/*
			跳出循环，说明我当前已经找到了第m个位置的学生，
			这时候，index所代表的是下一次循环的初始位置
			那么下次循环的初始位置的前面位置就是当前所要移除的学生的编号
			本来应该是index-1，这里加n再对n取模，是因为圆圈，
			比如：
					0

			4				1


				3		2
			例如当前移除的学生下标是4，下一次移除的时候，肯定要从0开始遍历，
			也就是当跳出上面这个while循环，index是等于0；如果要去标记4被移除的话，
			不能直接用0-1，所以通过加n再对n取模，得到下标4的位置。
			
			*/
            vis[(index + n - 1) % n] = true;//标记当前循环移除的学生位置的下标
            sum++;//说明当前成功的移除了一名学生

        }
		/*
			这里添加这个while循环意思是：
			比如说我现在移除同学，只剩下了2个人，
			移除过程中，其实这些同学的位置并没有进行移除，只是通过vis[]数组进行了标记
			所以，我还是有可能去遍历到已经移除过的学生的位置
			所以当我移除到只剩下1个学生的时候，这个index有可能处在已经移除过的学生的位置
			所以在返回index之前，还是需要将index放到没有被移除过的学生的位置

		*/
        //在返回结果时，让index处于没有被移除的学生位置
        while (vis[index]) {
            index = (index + 1) % n;
        }
        return index;
    }
}





